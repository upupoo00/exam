# 网络原理之TCP/IP

#  TCP/IP五层(或四层)模型

TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求
> - 物理层: 负责光/电信号的传递方式。物理层的能力决定了最大传输速率、传输距离、抗干扰性等.。集线器(Hub)工作在物理层
>  - 数据链路层:负责设备之间的数据帧的传送和识别。交换机(Switch)工作在数据链路层
>   - 网络层: 负责地址管理和路由选择。路由器(Router)工作在网路层
>    - 传输层:负责两台主机之间的数据传输
>    - 应用层:负责应用程序间沟通，即应用程序直接打交道的协议

![模型图](https://img-blog.csdnimg.cn/20210421123723600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
由于物理层我们考虑的比较少，因此也叫TCP/IP四层模型

一般而言：
> - 对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容;
> - 对于一台路由器, 它实现了从网络层到物理层;
> - 对于一台交换机, 它实现了从数据链路层到物理层;
> - 对于集线器, 它只实现了物理层

但是并不是绝对的，很多交换机也实现了网络层的转发; 很多路由器也实现了部分传输层的内容(比如端口转发);上述内容仅仅适用于笔试
#  TCP/IP协议
##  1.应用层
---
TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421124413107.png)
TCP/IP应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接受服务的程序叫客户端。在这种通信模式中，提供服务的程序会预先被部署到主机上，等待接受任何时刻客户可能发送的请求。
 客户端可以随时发送请求给服务端。有时服务端可能会有处理异常、超出负载等情况，这时客户端可以在等待片刻后重发一次请求。
## 2. 传输层
**TCP**
 TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。
 然后，为了建立断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议（音频、视频的数据量既定）等场合使用。

**UDP**
 UDP有别于TCP,它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。
 UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。
###  2.1端口号
端口号（port）标示了一个主机上进行通信的不同的应用程序；
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421125323403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
 在TCP/IP协议中, 用 "源IP", "源端口号", "目的IP", "目的端口号", "协议号" 这样一个五元组来标识一个通信(可以通过netstat -n查看);![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421125419922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
####  端口号划分
> - 0 - 1023: 知名端口号,HTTP,FTP,SSH等这些
>  - 1024-65535: 操作系统动态分配的端口号。客户端程序的端口号，就是由操作系统从这个范围分配的。
> ####  认识知名端口号
> - ssh服务器，22
>  - ftp服务器，21
>   - telnet服务器，23
>    - http服务器，80
>    - https服务器，443
>    - DNS服务器，53

自己写程序时，要避开这些端口号
[详情请参见百度百科](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3/792237?fr=aladdin)
### 2.2 UDP协议
####  UDP协议端格式
![UDP协议格式](https://img-blog.csdnimg.cn/20210421131207533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)

> - 16位UDP长度，表示整个数据报(UDP首部+UDP数据) 的最大长度
> - 如果效验出错，就会直接丢弃
> ####  UDP的特点
> 我们可以举个例子：UDP传输就像是寄信或者发短信，就算对方没有回应，你还是可以继续发送
> - 无连接:知道对端的IP和端口号就直接进行传输，不需要建立连接；
> - 不可靠:没有确认机制;没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息
> - 面向数据报:不能够灵活的控制读写数据的次数和数量;
> ####  面向数据报
> 应用层交给UDP多长的报文，UDP还是原样发送，既不会拆分，也不会合并；
> ####  UDP的缓冲区
> - UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作;
> - UDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果缓冲区满了, 再到达的UDP数据就会被丢弃;

UDP的Socket既能读，也能写，这个概念叫做全双工
####  解决方案
我们注意到, UDP协议首部中有一个16位的最大长度. 也就是说一个UDP能传输的数据最大长度是64K(包含UDP首部).
如果我们需要传输的数据超过64K, 就需要在应用层手动的分包, 多次发送, 并在接收端手动拼装;
那么如何解决这个问题呢
>1. 从应用层来分离和组装数据(程序员)
>2. 大包的方式去发，在数据链路层进行分包和组包.(交给协议自动处理)
>
>####  基于UDP的应用层协议
- NFS: 网络文件系统
- TFTP: 简单文件传输协议
- DHCP: 动态主机配置协议
- BOOTP: 启动协议(用于无盘设备启动)
- DNS: 域名解析协议

当然, 也包括你自己写UDP程序时自定义的应用层协议

###  2.3TCP协议
TCP全称为 "传输控制协议(Transmission Control Protocol"). 人如其名, 要对数据的传输进行一个详细的控制;
####  TCP协议段格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042119561747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
- 源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去;
- 32位序号/32位确认号: 后面详细讲;
- 4位TCP报头长度: 表示该TCP头部有多少个32位bit(有多少个4字节); 所以TCP头部最大长度是15* 4= 60
- 6位标志位:
  - URG: 紧急指针是否有效
   - ACK: 确认号是否有效
   -  PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
   - RST: 对方要求重新建立连接; 我们把携RST标识的称为复位报文段
   - SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段
  - FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段
  
- 16位窗口大小: 后面有详细介绍
- 16位校验和: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题. 此处的检验和不光包含TCP首部, 也包含TCP数据部分.
- 16位紧急指针: 标识哪部分数据是紧急数据;
- 40字节头部选项: 暂时忽略;
####   TCP 八大特性
##### 确认应答
![确认应答机制](https://img-blog.csdnimg.cn/20210421200330824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
TCP将每个字节数据都进行了编号。即为序列号
![发送数据](https://img-blog.csdnimg.cn/20210421200613708.png)
 每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据; 下一次你从哪里开始发
#####  超时重传
![设计思路](https://img-blog.csdnimg.cn/20210421200804143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421200834993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> - 主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B;
>  - 如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发;

但是, 主机A未收到B发来的确认应答, 也可能是因为ACK丢失了;
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421201016631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
因此主机B会收到很多重复数据. 那么TCP协议需要能够识别出那些包是重复的包, 并且把重复的丢弃掉.

这时候我们可以利用前面提到的序列号, 就可以很容易做到去重的效果.

那么, 如果超时的时间如何确定?
> - 最理想的情况下, 找到一个最小的时间, 保证 "确认应答一定能在这个时间内返回".
> - 但是这个时间的长短, 随着网络环境的不同, 是有差异的.
> - 如果超时时间设的太长, 会影响整体的重传效率;
> - 如果超时时间设的太短, 有可能会频繁发送重复的包;

TCP为了保证无论在任何环境下都能比较高性能的通信, 因此会动态计算这个最大超时时间.
> - Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍.
> - 如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传.
> - 如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增.
> - 累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接.
> #####  连接管理
> 在正常情况下, TCP要经过三次握手建立连接, 四次挥手断开连接；
> ![连接管理](https://img-blog.csdnimg.cn/20210421202414926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> ######  TCP状态转化汇总
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421202749178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> ######  TCP特性：有连接
> 有连接必须要证明4个
>
> 1.  发送的发送能力(话筒)
2. 发送的接收能力(耳机)
3. 接收的发送能力(对方的话筒)
4. 接收方的接收能力(对方的耳机)
######  CLOSE_WAIT的说明
一般而言，对于服务器上出现大量的 CLOSE_WAIT 状态, 原因就是服务器没有正确的关闭 socket, 导致四次挥手没有正确完成. 这是一个 BUG. 只需要加上对应的 close 即可解决问题

就是说:你的程序有BUG，没有调用close()方法
######  TIME_WAIT的说明
为什么是TIME_WAIT的时间是2MSL?
> - MSL是TCP报文的最大生存时间, 因此TIME_WAIT持续存在2MSL的话
> - 就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失(否则服务器立刻重启,可能会收到来自上一个进程的迟到的数据, 但是这种数据很可能是错误的);
> - 同时也是在理论上保证最后一个报文可靠到达(假设最后一个ACK丢失, 那么服务器会再重发一个FIN. 这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK)

TIME_WAIT = 等ACK到对方1MSL+FIN最大发送时间1MSL
#####  滑动窗口
刚才我们讨论了确认应答策略, 对每一个发送的数据段, 都要给一个ACK确认应答. 收到ACK后再发送下一个数据段. 这样做有一个比较大的缺点, 就是性能较差. 尤其是数据往返的时间较长的时候.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421203744454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
既然这样一发一收的方式性能较低, 那么我们一次发送多条数据, 就可以大大的提高性能(其实是将多个段的等待时间重叠在一起了)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042120391696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> - 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值. 上图的窗口大小就是4000个字节(四个段).
> - 发送前四个段的时候, 不需要等待任何ACK, 直接发送;
> - 收到第一个ACK后, 滑动窗口向后移动, 继续发送第五个段的数据; 依次类推;
> - 操作系统内核为了维护这个滑动窗口, 需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉;
>  - 窗口越大, 则网络的吞吐率就越高;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421204118676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
那么如果出现了丢包, 如何进行重传? 这里分两种情况讨论

情况一：数据包已经抵达，ACK被丢了
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421204235880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
这种情况下, 部分ACK丢了并不要紧, 因为可以通过后续的ACK进行确认;当返回ack = 6001说明服务器端已经接收到1 -6000的数据了

情况二： 数据包就直接丢了
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421204417158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> - 当某一段报文段丢失之后, 发送端会一直收到 1001 这样的ACK, 就像是在提醒发送端 "我想要
> 的是 1001" 一样;
> - 如果发送端主机连续三次收到了同样一个 "1001" 这样的应答, 就会将对应的数据 1001 -2000 重新发送;
> - 这个时候接收端收到了 1001 之后, 再次返回的ACK就是7001了(因为2001 - 7000)接收端其实之前就已经收到了, 被放到了接收端操作系统内核的接收缓冲区中;

 当接收到1001-2000之后，返回的ack是7001，这种机制被称为高速重发限制也叫（快重传）
#####  流量控制
顾名思义，就是根据接收缓冲区的实际情况，控制发送的速度 ——>根据结果控制

接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送, 就会造成丢包, 继而引起丢包重传等等一系列连锁反应.
因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫做流量控制(FlowControl);
> - 接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 "窗口大小" 字段, 通过ACK端通知发送端;
> - 窗口大小字段越大, 说明网络的吞吐量越高;接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;
> - 发送端接受到这个窗口之后, 就会减慢自己的发送速度;
>  - 如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421204922317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
接收端如何把窗口大小告诉发送端呢? 回忆我们的TCP首部中, 有一个16位窗口字段, 就是存放了窗口大小信息;

那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?

实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M, 实际窗口大小是 窗口字段的值左移 M 位;
#####  拥塞控制
######  规则
> 规则：发包从1开始，默认值为16，当小于此值的时候，以指数增长的方式发包，当等于这个值就以线性增长的方式发包，一直到有大量丢包的请求(发包已经到当前时间段的极致)；这个时候就会将发包值置位1，然后再将临界值设置为最大发包值的一般，继续重复此过程

虽然TCP有了滑动窗口这个大杀器, 能够高效可靠的发送大量的数据. 但是如果在刚开始阶段就发送大量的数据, 仍然可能引发问题.

因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. 在不清楚当前网络状态下, 贸然发送大量的数据, 是很有可能引起雪上加霜的.

TCP引入 慢启动 机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态, 再决定按照多大的速度传输数据;
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421210040519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)

> - 此处引入一个概念程为拥塞窗口
> - 发送开始的时候, 定义拥塞窗口大小为1;
> - 每次收到一个ACK应答, 拥塞窗口加1;
> - 每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实
> 际发送的窗口;

像上面这样的拥塞窗口增长速度, 是指数级别的. "慢启动" 只是指初使时慢, 但是增长速度非常快.
>- 为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍.
>- 此处引入一个叫做慢启动的阈值
>- 当拥塞窗口超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421205322121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
> - 当TCP开始启动的时候, 慢启动阈值等于窗口最大值;
> - 在每次超时重发的时候, 慢启动阈值会变成原来的一半, 同时拥塞窗口置回1

少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞;

当TCP通信开始后, 网络吞吐量会逐渐上升; 随着网络发生拥堵, 吞吐量会立刻下降;

拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案.

TCP拥塞控制这样的过程, 就好像 热恋的感觉

#####  延迟应答
延时应答是在流量控制的基础上，优化发送效率

如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小
> - 假设接收端缓冲区为1M. 一次收到了500K的数据; 如果立刻应答, 返回的窗口就是500K;
> - 但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了;
> - 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来;
> - 如果接收端稍微等一会再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M

一定要记得, 窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率;

那么所有的包都可以延迟应答么? 肯定也不是
> - 数量限制: 每隔N个包就应答一次;
> - 时间限制: 超过最大延迟时间就应答一次

> 注意事项：延迟应答时间不能超过MSL（最大生存时间） 如果超过MSL 就会触发超时重传 它会以为消息丢失

具体的数量和超时时间, 依操作系统不同也有差异; 一般N取2, 超时时间取200ms;
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421205942768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
#####  捎带应答
是用来提高消息传输的性能，在延迟应答的基础上继续优化传输效率的

在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 "一发一收" 的. 意味着客户端给服务器说了 "How are you", 服务器也会给客户端回一个 "Fine, thank you";

那么这个时候ACK就可以搭顺风车, 和服务器回应的 "Fine, thank you" 一起回给客户端
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421210224905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
#####  一个问题：沾包问题
[八戒吃馒头的例子]
>- 首先要明确, 粘包问题中的 "包" , 是指的应用层的数据包.
>- 在TCP的协议头中, 没有如同UDP一样的 "报文长度" 这样的字段, 但是有一个序号这样的字段.
>- 站在传输层的角度, TCP是一个一个报文过来的. 按照序号排好序放在缓冲区中.
>- 站在应用层的角度, 看到的只是一串连续的字节数据.
>- 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分, 是一个完整的应用层数据包
>
>[那么如何避免粘包问题呢? 归根结底就是一句话, 明确两个包之间的边界.]
>- 对于定长的包, 保证每次都按固定大小读取即可; 例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可;
>- 对于变长的包, 可以在包头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;
>- 对于变长的包, 还可以在包和包之间使用明确的分隔符(应用层协议, 是程序猿自己来定的, 只要保证分隔符不和正文冲突即可);

说到这里，就不得不提到UDP协议，那么对于UDP协议，是否也存在"沾包问题"呢？
> - 对于UDP, 如果还没有上层交付数据, UDP的报文长度仍然在. 同时, UDP是一个一个把数据交付给应用层. 就有很明确的数据边界.
> - 站在应用层的站在应用层的角度, 使用UDP的时候, 要么收到完整的UDP报文, 要么不收. 不会出现"半个"的情况

#####  面向字节流
创建一个TCP的socket, 同时在内核中创建一个 发送缓冲区 和一个 接收缓冲区;
>- 调用write时, 数据会先写入发送缓冲区中;
>如果发送的字节数太长, 会被拆分成多个TCP的数据包发出;
>- 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出去;
>- 接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区;
>- 然后应用程序可以调用read从接收缓冲区拿数据;
>- 另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做 全双工

由于缓冲区的存在, TCP程序的读和写不需要一一匹配, 例如：
> - 写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节;
> - 读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次read一个字节, 重复100次

#####  TCP异常情况
进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别.

机器重启: 和进程终止的情况相同.

机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在,也会把连接释放.

另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会定期检测对方的状态. 例如QQ, 在QQ断线之后, 也会定期尝试重新连接

#####  TCP小结
为什么TCP那么复杂呢？因为要保证可靠性，同时尽可能提高性能

可靠性：
>- 校验和
>- 序列号(按序到达)
>- 确认应答
>- 超时重发
>- 连接管理
>- 流量控制
>- 拥塞控制

提高性能：
>- 滑动窗口
>- 快速重传
>- 延迟应答
>- 捎带应答

其他：
>- 定时器（超时重传定时器，保活定时器，TIME_WAIT定时器等）

####  2.4TCP/UDP对比
TCP VS UDP
1. UDP是无连接的，TCP是有连接的
2. UDP是不稳定的，TCP是稳定的
3. UDP是面向数据报的，TCP是面向数据流的
4. UDP没有发送缓冲区，TCP有发送缓冲区
5. UDP是以高效著称的，TCP是以稳定性著称的

我们说了TCP是可靠连接, 那么是不是TCP一定就优于UDP呢? TCP和UDP之间的优点和缺点, 不能简单,绝对的进行比较
>- TCP用于可靠传输的情况, 应用于文件传输, 重要状态更新等场景;
>- UDP用于对高速传输和实时性要求较高的通信领域, 例如, 早期的QQ, 视频传输等. 另外UDP可以用于广播

归根到底，TCP/UDP都是工具，还要结合具体情况进行使用

面试题：用UDP实现可靠传输

我们可以参考TCP的可靠性机制
>- 引入序列号, 保证数据顺序;
>- 引入确认应答, 确保对端收到了数据;
>- 引入超时重传, 如果隔一段时间没有应答, 就重发数据;

##  3.网络层
###  3.1 IP协议
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421212632787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
####  基本概念
主机: 配有IP地址, 但是不进行路由控制的设备;
路由器: 即配有IP地址, 又能进行路由控制;
节点: 主机和路由器的统称;
####  协议头格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421214608273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- 4位版本号(version): 指定IP协议的版本, 对于IPv4来说, 就是4.
>- 4位头部长度(header length): IP头部的长度是多少个32bit, 也就是 length * 4 的字节数. 4bit表示最大的数字是15, 因此IP头部最大长度是60字节.
>- 8位服务类型(Type Of Service): 3位优先权字段(已经弃用), 4位TOS字段, 和1位保留字段(必须置为0). 4位TOS分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本. 这四者相互冲突, 只能选择一个. 对于ssh/telnet这样的应用程序, 最小延时比较重要; 对于ftp这样的程序, 最大吞吐量比较重要.
>- 16位总长度(total length): IP数据报整体占多少个字节.
>- 16位标识(id): 唯一的标识主机发送的报文. 如果IP报文在数据链路层被分片了, 那么每一个片里面的这个id都是相同的.
>- 3位标志字段: 第一位保留(保留的意思是现在不用, 但是还没想好说不定以后要用到). 第二位置为1表示禁止分片, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. 第三位表示"更多分片", 如果分片了的话, 最后一个分片置为1, 其他是0. 类似于一个结束标记.
>- 13位分片偏移(framegament offset): 是分片相对于原始IP报文开始处的偏移. 其实就是在表示当前分片在原报文中处在哪个位置. 实际偏移的字节数是这个值 * 8 得到的. 因此, 除了最后一个报文之外, 其他报文的长度必须是8的整数倍(否则报文就不连续了).
>- 8位生存时间(Time To Live, TTL): 数据报到达目的地的最大报文跳数. 一般是64. 每次经过一个路由, TTL -= 1, 一直减到0还没到达, 那么就丢弃了. 这个字段主要是用来防止出现路由循环
>8位协议: 表示上层协议的类型
>- 16位头部校验和: 使用CRC进行校验, 来鉴别头部是否损坏.
>- 32位源地址和32位目标地址: 表示发送端和接收端.
>- 选项字段(不定长, 最多40字节): 略

###  3.2网段划分(重要掌握)
IP地址分为两个部分, 网络号和主机号
>- 网络号: 保证相互连接的两个网段具有不同的标识;
>- 主机号: 同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号;

通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同

那么问题来了, 手动管理子网内的IP, 是一个相当麻烦的事情
>- 有一种技术叫做DHCP, 能够自动的给子网内新增主机节点分配IP地址, 避免了手动管理IP的不便.
>- 一般的路由器都带有DHCP功能. 因此路由器也可以看做一个DHCP服务器

过去曾经提出一种划分网络号和主机号的方案, 把所有IP 地址分为五类
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421215612450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- A类 0.0.0.0到127.255.255.255
>- B类 128.0.0.0到191.255.255.255
>- C类 192.0.0.0到223.255.255.255
>- D类 224.0.0.0到239.255.255.255
>- E类 240.0.0.0到247.255.255.255

随着Internet的飞速发展,这种划分方案的局限性很快显现出来,大多数组织都申请B类网络地址, 导致B类地址很快就分配完了, 而A类却浪费了大量地址;
>- 例如, 申请了一个B类地址, 理论上一个子网内能允许6万5千多个主机. A类地址的子网内的主机数更多.
>- 然而实际网络架设中, 不会存在一个子网内有这么多的情况. 因此大量的IP地址都被浪费掉了

针对这种情况提出了新的划分方案, 称为CIDR(Classless Interdomain Routing):
>- 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号;
>- 子网掩码也是一个32位的正整数. 通常用一串 "0" 来结尾;
>- 将IP地址和子网掩码进行 "按位与" 操作, 得到的结果就是网络号;
>- 网络号和主机号的划分与这个IP地址是A类、B类还是C类无关;


举个例子
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421215922447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
可见,IP地址与子网掩码做与运算可以得到网络号, 主机号从全0到全1就是子网的地址范围;

IP地址和子网掩码还有一种更简洁的表示方法,例如140.252.20.68/24,表示IP地址为140.252.20.68, 子网掩码的高24位是1,也就是255.255.255.0
####  特殊的IP地址
>- 将IP地址中的主机地址全部设为0, 就成为了网络号, 代表这个局域网;
>- 将IP地址中的主机地址全部设为1, 就成为了广播地址, 用于给同一个链路中相互连接的所有主机发送数据包;
>- 127.*的IP地址用于本机环回(loop back)测试,通常是127.0.0.1

####  IP数量的限制
我们知道, IP地址(IPv4)是一个4字节32位的正整数. 那么一共只有 2的32次方 个IP地址, 大概是43亿左右.而TCP/IP协议规定, 每个主机都需要有一个IP地址.

这意味着, 一共只有43亿台主机能接入网络么?

实际上, 由于一些特殊的IP地址的存在, 数量远不足43亿; 另外IP地址并非是按照主机台数来配置的, 而是每一个网卡都需要配置一个或多个IP地址.

CIDR在一定程度上缓解了IP地址不够用的问题(提高了利用率, 减少了浪费, 但是IP地址的绝对上限并没有增加), 仍然不是很够用. 这时候有三种方式来解决:
>- 动态分配IP地址: 只给接入网络的设备分配IP地址. 因此同一个MAC地址的设备, 每次接入互联网中, 得到的IP地址不一定是相同的;
>- NAT技术(后面会重点介绍);
>- IPv6: IPv6并不是IPv4的简单升级版. 这是互不相干的两个协议, 彼此并不兼容; IPv6用16字节
>- 128位来表示一个IP地址; 但是目前IPv6还没有普及

#### 私有IP地址和公网IP地址
如果一个组织内部组建局域网,IP地址只用于局域网内的通信,而不直接连到Internet上,理论上 使用任意的IP地址都可以,但是RFC 1918规定了用于组建局域网的私有IP地址
>- 10.*,前8位是网络号,共16,777,216个地址
>- 172.16.到172.31.,前12位是网络号,共1,048,576个地址
>- 192.168.*,前16位是网络号,共65,536个地址
>包含在这个范围中的, 都成为私有IP, 其余的则称为全局IP(或公网IP);
>###  3.3路由
>路由就是：在复杂的网络结构中, 找出一条通往终点的路线;

路由的过程, 就是这样一跳一跳(Hop by Hop) "问路" 的过程.

所谓 "一跳" 就是数据链路层中的一个区间. 具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间.
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421220716488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
IP数据包的传输过程也和问路一样
>- 当IP数据包, 到达路由器时, 路由器会先查看目的IP;
>- 路由器决定这个数据包是能直接发送给目标主机, 还是需要发送给下一个路由器;
>- 依次反复, 一直到达目标IP地址;

那么如何判定当前这个数据包该发送到哪里呢? 这个就依靠每个节点内部维护一个路由表
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421220817915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- 路由表可以使用route命令查看
>- 如果目的IP命中了路由表, 就直接转发即可;
>- 路由表中的最后一行,主要由下一跳地址和发送接口两部分组成,当目的地址与路由表中其它行都不匹配时,就按缺省路由条目规定的接口发送到下一跳地址

## 4.数据链路层
###  4.1认识以太网
>- "以太网" 不是一种具体的网络, 而是一种技术标准; 既包含了数据链路层的内容, 也包含了一些物理层的内容. 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等;
>- 例如以太网中的网线必须使用双绞线; 传输速率有10M, 100M, 1000M等;
>- 以太网是当前应用最广泛的局域网技术; 和以太网并列的还有令牌环网, 无线LAN等;

####  以太网帧格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421221344781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- 源地址和目的地址是指网卡的硬件地址(也叫MAC地址), 长度是48位,是在网卡出厂时固化的;
>- 帧协议类型字段有三种值,分别对应IP、ARP、RARP;
>- 帧末尾是CRC校验码

#### 认识MAC地址
>- MAC地址用来识别数据链路层中相连的节点;
>- 长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)
>- 在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的
>- mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址)

###  4.2对比MAC地址和IP地址
>- IP地址描述的是路途总体的 起点 和终点；
>- MAC地址描述的是路途上的每一个区间的起点和终点；

###  4.3认识MTU
MTU相当于发快递时对包裹尺寸的限制. 这个限制是不同的数据链路对应的物理层, 产生的限制
>- 以太网帧中的数据长度规定最小46字节,最大1500字节,ARP数据包的长度不够46字节,要在后
>面补填充位;
>- 最大值1500称为以太网的最大传输单元(MTU),不同的网络类型有不同的MTU;
>- 如果一个数据包从以太网路由到拨号链路上,数据包长度大于拨号链路的MTU了,则需要对数据包进行分片(fragmentation);
>- 不同的数据链路层标准的MTU是不同的;

####  MTU对IP协议的影响
由于数据链路层MTU的限制, 对于较大的IP数据包要进行分包
>- 将较大的IP包分成多个小包, 并给每个小包打上标签;
>- 每个小包IP协议头的 16位标识(id) 都是相同的;
>- 每个小包的IP协议头的3位标志字段中, 第2位置为0, 表示允许分片, 第3位来表示结束标记(当前是否是最后一个小包, 是的话置为1, 否则置为0);
>- 到达对端时再将这些小包, 会按顺序重组, 拼装到一起返回给传输层;
>- 一旦这些小包中任意一个小包丢失, 接收端的重组就会失败. 但是IP层不会负责重新传输数据;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421222036665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421222844841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)

####  MTU对UDP协议的影响
让我们回顾一下UDP协议：
>- 一旦UDP携带的数据超过1472(1500 - 20(IP首部) - 8(UDP首部)), 那么就会在网络层分成多个IP数据报.
>- 这多个IP数据报有任意一个丢失, 都会引起接收端网络层重组失败. 那么这就意味着, 如果UDP数据报在网络层被分片, 整个数据被丢失的概率就大大增加了

####  MTU对TCP协议的影响
让我们再回顾一下TCP协议：
>- TCP的一个数据报也不能无限大, 还是受制于MTU. TCP的单个数据报的最大消息长度, 称为
>MSS(Max Segment Size);
>- TCP在建立连接的过程中, 通信双方会进行MSS协商.
>- 最理想的情况下, MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据
>链路层的MTU).
>- 双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值.
>- 然后双方得知对方的MSS值之后, 选择较小的作为最终MSS.
>- MSS的值就是在TCP首部的40字节变长选项中(kind=2);

MSS和MTU的关系
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421222540564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
###  4.4 ARP协议
虽然我们在这里介绍ARP协议, 但是需要强调, ARP不是一个单纯的数据链路层的协议, 而是一个介于数据链路层和网络层之间的协议;
####  ARP协议的作用
ARP协议建立了主机 IP地址 和 MAC地址 的映射关系
>- 在网络通讯时,源主机的应用程序知道目的主机的IP地址和端口号,却不知道目的主机的硬件地址;
>- 数据包首先是被网卡接收到再去处理上层协议的,如果接收到的数据包的硬件地址与本机不符,
>则直接丢弃;
>- 因此在通讯前必须获得目的主机的硬件地址

##  5.重要应用层协议DNS(Domain Name System)
DNS是一整套从域名映射到IP的系统
###  5.1 DNS的背景
TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序. 但是IP地址不方便记忆.

于是人们发明了一种叫主机名的东西, 是一个字符串, 并且使用hosts文件来描述主机名和IP地址的关系
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421222939174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- DNS是应用层协议
>- DNS底层使用UDP进行解析
>- 浏览器会缓存DNS结果

####  浏览器中输入url后, 发生的事情
1. 浏览器会判断当前输入的url是否合规，即url是否正确
2. 浏览器会判断当前的url有没有缓存
3. DNS服务器(域名->IP)
4. TCP连接(3次握手)
5. 以HTTP协议的数据格式发送数据给服务端
6. ACK返回给客户端，告诉客户端我已经收到消息了
7. 服务器业务代码处理并且吧结果返回服务器
8. 浏览器拿到服务器返回的信息，执行渲染
9. 4次挥手正常断开连接

###  5.2  NAT技术
之前我们讨论了, IPv4协议中, IP地址数量不充足的问题

NAT技术当前解决IP地址不够用的主要手段, 是路由器的一个重要功能;
>- NAT能够将私有IP对外通信时转为全局IP. 也就是就是一种将私有IP和全局IP相互转化的技术方法:
>- 很多学校, 家庭, 公司内部采用每个终端设置私有IP, 而在路由器或必要的服务器上设置全局IP;
>- 全局IP要求唯一, 但是私有IP不需要; 在不同的局域网中出现相同的私有IP是完全不影响的;

####  缓解IPV4地址不够用的解决方案

> 1. IPV6（128位）[弊端：需要更换网络设备来支持IPV6]
> 2. NAT  
> 优点：缓解IPV4不够用的问题
>  缺点：NAT服务是有开销的
> 如果NAT服务器挂了，那么整个都会挂掉

####  NAT IP转换过程
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421223743130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
>- NAT路由器将源地址从10.0.0.10替换成全局的IP 202.244.174.37;
>- NAT路由器收到外部的数据时, 又会把目标IP从202.244.174.37替换回10.0.0.10;
>- 在NAT路由器内部, 有一张自动生成的, 用于地址转换的表;
>- 当 10.0.0.10 第一次向 163.221.120.9 发送数据时就会生成表中的映射关系

####  NAPT
那么问题来了, 如果局域网内, 有多个主机都访问同一个外网服务器, 那么对于服务器返回的数据中, 目的IP都是相同的. 那么NAT路由器如何判定将这个数据包转发给哪个局域网的主机?


这时候NAPT来解决这个问题了. 使用IP+port来建立这个关联关系
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421224018258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VwdXBvbzA=,size_16,color_FFFFFF,t_70)
这种关联关系也是由NAT路由器自动维护的. 例如在TCP的情况下, 建立连接时, 就会生成这个表项; 在断开连接后, 就会删除这个表项
####  NAT技术的缺陷
由于NAT依赖这个转换表, 所以有诸多限制:
>- 无法从NAT外部向内部服务器建立连接;
>- 装换表的生成和销毁都需要额外开销;
>- 通信过程中一旦NAT设备异常, 即使存在热备, 所有的TCP连接也都会断开

####  NAT和代理服务器
代理服务器看起来和NAT设备有一点像. 客户端像代理服务器发送请求, 代理服务器将请求转发给真正要请求的服务器; 服务器返回结果后, 代理服务器又把结果回传给客户端
那么NAT和代理服务器的区别有哪些呢？

a）所在层级不一样：代理服务器一般运行在应用层NAT运行在数据链路层
b）代理服务器通常是安装在电脑或者是手机上的，NAT服务器通常会安装在防火墙上
c）解决问题不同：NAT解决IP不够用的问题，代理服务器解决访问不了的问题

**代理服务器又分为正向代理和反向代理**

正向代理用于请求的转发(例如：借助代理绕过反爬虫)

反向代理往往作为一个缓存